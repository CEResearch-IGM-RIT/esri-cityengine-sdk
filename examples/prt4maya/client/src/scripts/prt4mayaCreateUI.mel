//
// Esri CityEngine SDK Maya Plugin Example
//
// This example demonstrates the main functionality of the Procedural Runtime API.
// Esri R&D Center Zurich, Switzerland
//
// See http://github.com/ArcGIS/esri-cityengine-sdk for instructions.

global proc string[] createPrtNode() {
	string $result[];
	string $select[] = `ls -sl`;
	
	if(!(size($select))) {
		confirmDialog -title "Missing selection" -message "Please select a polygon first in order to apply a rule." -button "OK";
		return $result;
	}

	$filters = "Rule Package (*.rpk);;All Files (*.*)";
	string $rulePackage[] = `fileDialog2 -fm 1 -cap "Select Rule Package" -ff $filters`;
	
	if(size($rulePackage)) {		
		for ( $node in $select ) {
			string $prtName = "<ignored>";
			if(`nodeType $node` == "prt") {
				setAttr -type "string" ($node + ".Rule_Package") $rulePackage[0];
				$prtName = $node;
			} else {
				if(`nodeType $node` == "transform") {
					string $children[] = `listRelatives -children $node`;
					for($child in $children) {
						if(`nodeType $child` == "mesh") {
							$node = $child;
							break;
						}
					}
				}

				if(`nodeType $node` == "mesh") {
					string $dsts[] = `connectionInfo -dfs ($node + ".outMesh")`;
					if(size($dsts)) {
						for($dst in $dsts) {
							string $dstNode = `match "[^.]*" $dst`;
							if(`nodeType $dstNode` == "prt") {
								setAttr -type "string" ($dstNode + ".Rule_Package") $rulePackage[0];
							}
						}
					} else {
						$prtName = `createNode prt`;
						$prtName = `rename $prtName "prt#"`;
						setAttr -type "string" ($prtName + ".Rule_Package") $rulePackage[0];
						string $parent[]  = `listRelatives -parent $node`;
						string $meshName;
						if(size($parent)) {
							$meshName = `createNode -parent $parent[0] mesh`;
						} else {
							$meshName = `createNode -parent $node mesh`;
						}
						$meshName = `rename $meshName "prtShape#"`;
						connectAttr ( ( $prtName + ".outMesh" ), ( $meshName + ".inMesh" ) );
						connectAttr ( ( $node + ".outMesh" ), ( $prtName + ".inMesh" ) );
						sets -addElement initialShadingGroup $meshName;
					}
				}
			}
			$result[size($result)] = $node;
			$result[size($result)] = $prtName;
		}
	}
	    
    return $result;
}

global proc createPrtMenu() {
	global string $gMainWindow;
	global string $gPrtMenu = "prtMenu"; 

	setParent $gMainWindow;
	if (`isTrue "BaseMayaExists"`) { 
		menu -l "PRT" -aob true -to true -postMenuCommandOnce true $gPrtMenu;
		setParent -m ..; 
		setParent -m $gPrtMenu;
		menuItem -divider true;
		menuItem -label "Attach Rule..."  -c "createPrtNode" -annotation "Attach a CGA rule package to a geometry";
		setParent -m ..;
	}
}

global proc prt4mayaCreateUI() {
 	createPrtMenu();
}

// --- shader setup helpers

proc string fileNameFromPath(string $filePath) {
	string $buffer[];
	int $nTok = `tokenize $filePath "/" $buffer`;
	return $buffer[$nTok-1];
}

global proc string createShadingGroup2(string $texFilePath) {
	if(size($texFilePath) == 0) {
		return "initialShadingGroup";
	}

	string $fileName = fileNameFromPath($texFilePath); 			// might not be unique!
	$fileName        = substituteAllString($fileName, ".", "_");		// '.' seems to be illegal	
	string $sgName   = "prtShadingGroup_" + $fileName;
	
	// if group with that name exists already: use it
	string $allSets[] = `ls -sets`;
	string $se;
	for($se in $allSets) {
		if($se == $sgName) return $sgName;
	}
		
	string $shName = "prtShader_" + $fileName;		
	string $fnName = "prtFile_" + $fileName;		

	shadingNode -asShader lambert -n $shName;
	sets -renderable true -noSurfaceShader true -empty -name $sgName;
	connectAttr -f ($shName + ".outColor") ($sgName + ".surfaceShader");

	shadingNode -asTexture file -n $fnName;
	connectAttr -force ($fnName + ".outColor") ($shName + ".color");
	setAttr ($fnName + ".fileTextureName") -type "string" $texFilePath;

	return $sgName;
}

global proc string createShadingGroup(string $name) {
	string $sgName = "prtSG_" + $name;
	string $shName = "prtSH_" + $name;

	// if group with that name exists already: use it
	string $allSets[] = `ls -sets`;
	string $se;
	for($se in $allSets) {
		if($se == $sgName) return $sgName;
	}
	
	shadingNode -asShader lambert -n $shName;
	sets -renderable true -noSurfaceShader true -empty -name $sgName;
	connectAttr -f ($shName + ".outColor") ($sgName + ".surfaceShader");
	
	return $sgName;
}

global proc prtSetDiffuseTexture(string $sgName, string $texturePath, string $uvSet) {
	$shaderPlug = `connectionInfo -sfd ($sgName + ".surfaceShader")`;
	$shName = `plugNode $shaderPlug`;

	string $fileName = fileNameFromPath($texturePath); 			// might not be unique!
	$fileName = substituteAllString($fileName, ".", "_");		// '.' seems to be illegal

	string $nodeName = "prtFile_" + $fileName;

	shadingNode -asTexture file -n $nodeName;
	connectAttr -force ($nodeName + ".outColor") ($shName + ".color");
	setAttr ($nodeName + ".fileTextureName") -type "string" $texturePath;
}

global proc prtSetColor(string $sgName, float $r, float $g, float $b) {
	$shaderPlug = `connectionInfo -sfd ($sgName + ".surfaceShader")`;
	$shName = `plugNode $shaderPlug`;

	string $nodeName = "prtColor_" + $r + "_" + $g + "_" + $b;
	$nodeName = substituteAllString($nodeName, ".", "_");

	shadingNode -asShader blinn -n $nodeName;
	setAttr ($nodeName + ".color") -type "double3" $r $g $b;
	connectAttr -force ($nodeName + ".outColor") ($shName + ".color");
}

